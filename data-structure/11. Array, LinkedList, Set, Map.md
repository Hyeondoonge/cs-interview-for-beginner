# 자료구조

## Array, LinkedList, Set, Map 비교

### 시간복잡도

|  | 탐색 | 삽입  | 삭제  |
| --- | --- | --- | --- |
| Array | O(1) | O(n) | O(n) |
| LinkedList | O(n) | O(1) | O(1) |
| Set | O(logn) | O(logn) | O(logn) |
| Map | O(logn) | O(logn) | O(logn) |

**( Array에서 바로 참조값을 안다는 가정, Set,Map이 이진탐색트리로 구현돼 있다는 가정 )**

### Array

- 연속된 메모리 공간에 데이터 값이 저장되는 자료구조
- 논리적 저장 순서와 물리적 저장 순서가 동일 → Random Access 접근 가능하기 때문에 빠르다
- 데이터의 삽입,삭제가 어렵다 → 데이터를 shfit 해줘야 함
- Cache Hit Rate이 높다
- ex) 데이터가 순차적으로 저장되어야 하는 경우, 삽입 삭제가 빈번하게 일어나지 않고 크기 변경이 거의 없는 경우

### LinkedList

- 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조
- 데이터의 삽입,삭제가 쉽다 → 포인터만 바꾸면 됨
- 인덱스가 없기 때문에, 데이터의 탐색시 성능이 떨어짐
- Cache Hit Rate이 낮다
- ex) 데이터의 삽입,삭제가 빈번한 경우 (큐,스택)

### Set

- 중복되지 않은 데이터를 저장하는 자료구조
- 순서를 보장하지 않음
- 빠른 검색 속도를 가진다.
- ex) 데이터의 중복을 제거해야 하는 경우

### Map

- key-value의 한 쌍으로 데이터를 저장하는 자료구조
- 키를 이용해 데이터 값을 검색할 수 있음
- 순서를 보장하지않음
- 빠른 검색 속도를 가진다.
- ex) key-value 쌍으로 데이터를 저장해야 하는경우 (전화번호부)

---

## Java에서 List,Set,Map 비교

![image](https://user-images.githubusercontent.com/77667212/233831166-9b3e43d2-fee4-4e1e-ba39-b141d2465e56.png)


**Set과 List는 Collection 인터페이스를 구현하고 있고 Map은 인터페이스를 구현하고 있지 않다.**

- Collection을 상속한 것들
    - List
        - 순서가 있는 데이터 집합
        - 데이터를 중복해서 포함 가능
    - Set
        - 데이터의 중복을 허용하지 않는 데이터 집합 (value의 중복 허용 X)
        - 순서를 보장하지 않음
- Map
    - key와 value의 한 쌍으로 이루어진 데이터 집합
    - 순서를 보장하지 않음
    - key의 중복은 허용하지 않지만, value의 중복은 허용함

![image](https://user-images.githubusercontent.com/77667212/233831199-4e48b939-4a1f-424d-88c0-938593b15b4e.png)

Collection 인터페이스 위에는 Iterable이라는 인터페이스가 있고 이 인터페이스는 iterator 라는 추상 메서드를 갖고 있다.

### List

- **ArrayList**
    - 내부적으로 배열을 사용하는 자료구조로 **메모리가 연속적으로 배치**된다.
    - 배열과 달리 메모리 할당이 동적이다.
    - 데이터 삽입, 삭제 시 해당 데이터 이후 모든 데이터가 복사되므로 빈번한 **삭제, 삽입이 일어나는 경우에는 부적합**하다.
    - 검색의 경우는 인덱스의 데이터를 가져오면 되므로 빠르다.
    - **재할당 시 크기의 절반씩 증가한다.**
- **LinkedList**
    - 양방향 포인터 구조로 **각 노드가 데이터와 포인터**를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조
    - 데이터의 삽입, 삭제 시 해당 노드의 주소지만 바꾸면 되므로 삽입, 삭제가 빈번한 데이터에 적합하다.
    - 메모리가 **불연속적**이다.
    - 데이터 검색 시 처음부터 순회하므로 **검색에는 부적합**하다.
    - 스택, 큐, 양방향 큐를 만들기 위한 용도로 사용한다.
    - 양옆의 정보만을 갖고 있기 때문에 순차적으로 검색을 진행하여 검색 속도가 느리다.
- Vector
    - 내부에서 자동으로 동기처리가 일어난다.
    - 성능이 좋지 않아 잘 사용하지 않는다.
    - **재할당 시 크기의 두 배로 증가한다.**

### cf) 배열과 리스트는 다른 것

- 배열(Array)은 크기가 고정적이라 선언 시 지정한 크기를 변경할 수 없다.(Immutable)

### Set

- **HashSet**
    - **저장 순서를 유지하지 않는** 데이터의 집합
    - **Null 저장 가능**
    - 해시 알고리즘을 사용하여 검색속도가 매우 빠르다.
    - 내부적으로 HashMap 인스턴스를 이용하여 요소를 저장한다.
- **LinkedHashSet**
    - **저장 순서를 유지**하는 HashSet
- **TreeSet**
    - 데이터가 정렬된 상태로 저장되는 이진 탐색 트리의 형태로 요소를 저장한다.
    - **Null 저장 불가능**
    - **레드 블랙 트리(균형 이진 탐색 트리)** 로 구현되어 있다.
    - Compartor 구현으로 정렬 방법을 지정할 수 있다.
    

### Map

- **HashMap**
    - 내부 hash값에 따라 키순서가 정해지므로 특정 규칙없이 출력된다.
    - key와 value에 **null값을 허용** 한다.
    - 비동기 처리
- **LinkedHashMap**
    - **입력 순서대로 출력**된다.
    - 비동기 처리
- TreeMap
    - 내부적으로 **레드-블랙 트리(균형 이진 탐색 트리)** 로 저장된다.
    - **Null값 비허용**
    - 키값이 기본적으로 **오름차순 정렬** 되어 출력된다.
    - Compartor 구현으로 정렬 방법을 지정할 수 있다.
- ConCurrentHashMap
    - key,value에 null값 비허용
    - **쓰기작업에서만 동기 처리**
- HashTable
    - key,value에 null값 비허용
    - **모든 작업에 동기 처리**
    

Reference

[https://github.com/backtony/Backend_Interview_for_Beginner/blob/master/Java.md](https://github.com/backtony/Backend_Interview_for_Beginner/blob/master/Java.md)
