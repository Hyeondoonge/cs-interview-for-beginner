## 과정

1. 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.
2.  정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
3. 각 부분 리스트를 재귀적으로 병합 정렬을 이용해 정렬한다.
4. 두 부분 리스트를 하나의 정렬된 리스트로 병합한다.

> **Divide**
>

입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.

> **Conquer**
>

부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.

> **Combine**
>

정렬된 부분 배열들을 하나의 배열에 병합한다.

![1](https://user-images.githubusercontent.com/72093196/235566639-b896539a-7eea-4664-8899-85b69c39e336.png)

## 예시

![2](https://user-images.githubusercontent.com/72093196/235566636-082b5816-8e6d-47e6-9e11-4f42f48b8264.png)

## 특징

- 레코드를 배열로 구성하면, 임시 배열이 필요하다.
    - 제자리 정렬 X
- 레코드를 연결 리스트로 구성하며느 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
    - 제자리 정렬 O
- 안정적인 정렬 방법
    - 데이터의 분포에 영향을 덜 받는다.
    - 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다.
    - 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용하면, 병합 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적이다.

## 시간복잡도

- 분할 단계
    - 비교연산과 이동 연산이 수행되지 않는다.
- 병합 단계
    - 비교 횟수: $`nlog_2(n)`$
        - 순환 호출의 깊이 : $`log_2(n)`$
        - 각 합병 단계의 비교 연산 : $`n`$

      ![3](https://user-images.githubusercontent.com/72093196/235566630-f278f5ae-72f3-431a-b249-14af1a571662.png)

    - 이동 횟수: $`2nlog_2(n)`$
        - 순환 호출의 깊이 : $`log_2(n)`$
        - 각 합병 단계의 이동 연산: $`2n`$
            - 임시 배열에 복사: $`n`$
            - 다시 가져옴: $`n`$

```math
T(n) = nlog_2(n) + 2nlog_2(n) = O(nlog_2(n))
```

### Reference

[https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html](https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html)