## Hash table

키를 해시함수에 입력해서 얻어낸 해시값을 배열의 인덱스로 사용함으로써 평균적으로 O(1)의 빠른 탐색시간을 제공하는 자료구조이다.

하지만 해시 성능이 좋지않다면 충돌이 잦게 발생하게되며, 저장된 데이터의 크기에 비례하는 탐색시간이 발생할 수 있다.

### 충돌 해결

충돌이 발생할 때 해결하는 방법은 크게 개방 주소 방식과 폐쇄 주소 방식으로 나뉜다.

1. 개방 주소 방식(Open addressing)

   충돌이 발생하면 다른 빈 원소를 찾아 저장한다.

- 선형 조사(Linear probing)

  충돌이 발생한 곳부터 선형적으로 탐색한다. 해시 테이블의 끝에 도달하면 첫번째 인덱스부터 탐색을 이어나간다.
  군집화 문제가 발생할 수 있다는 단점이 있다.

```
(h(key) + i) % M, i = 0, 1, 2, 3, ...
```

- 이차 조사(Quadratic probing)

  총돌이 발생한 곳부터 선형적으로 증가하는 수를 제곱한 크기만큼 떨어진 곳에서 탐색한다.
  empty 항목이 있는대도 탐색에 실패할 수 있다는 것과 군집화 문제가 발생할 수 있다는 단점이 있다.

```
(h(key) + i^2) % M, i = 0, 1, 2, 3, ...
```

- 이중 해싱(Double hashing)

  해시함수를 두 개 사용한다. 해시함수로부터 얻은 점프 크기만큼 반복해서 늘려가며 충돌이 발생한 곳부터 해당 크기만큼 떨어진 곳의 탐색한다.
  동일한 해시값을 가지는 키여도 다른 점프 시퀀스를 가지므로 군집화 문제가 발생하지 않는 장점을 가진다. 하지만 추가적인 계산비용이 발생하는 단점을 가진다.

```
(h1(key) + i * h2(key)) % M, i = 0, 1, 2, 3, ...
```

2. 폐쇄 주소 방식(Closed addressing)

충돌이 발생하면, 빈 원소를 찾지않고 충돌이 일어난 곳에 저장한다.

- 분리 연결법(Seperate chaining)

  연결리스트 또는 트리 자료구조를 이용해 해시테이블의 각 원소에 동일한 해시값을 갖는 데이터들을 저장한다.

  - 연결리스트

    구현이 단순하고 트리에 비해 적은 메모리 사용한다는 장점을 가진다.

  - 트리

    AVL 또는 레드블랙트리 등이 사용된다. 연결리스트를 이용할 때보다 빠른 탐색이 가능하지만, 더 많은 메모리를 필요로하는 단점이 있다.

### 재해싱

재해싱은 해시 성능이 저하될 때, 해시테이블의 크기를 늘리고 새로운 해시함수를 적용하여 해시테이블에 다시 저장하는 방식이다. 즉, 해시테이블에 빈 공간이 점점 줄어들어 충돌이 잦게 발생할 때 적용하여 개선할 수 있다.

적재율을 기준으로 재해싱 수행여부를 판단하며 일반적으로 적재율(테이블에 저장된 키의 수 / 해시테이블의 크기)이 0.75이상일 때 해시테이블의 크기를 2배로 늘리고, 0.25이하일 때는 크기를 절반 줄인다고 한다.

이는 해시테이블의 크기를 늘린 후 이미 저장된 데이터를 다시 저장해야하므로 O(N)의 시간복잡도를 갖는 방법이다.
