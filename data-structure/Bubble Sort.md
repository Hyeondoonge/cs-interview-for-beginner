## Bubble Sort

⇒ 서로 **인접하는 두 원소의 대소를 비교**하고, 조건에 맞지 않으면 자리를 교환하며 정렬하는 방식 

### Process

1. 각 for 문마다 첫 번째 원소와 두 번째 원소, 두 번째 원소와 세 번째 원소… (N-1)번째 원소와 마지막 원소를 비교하여 서로 교환하는 방식
2. 1회전을 수행시, 가장 큰 원소가 마지막 원소로 이동하게 되고, 2회전시 맨 끝에 있는 원소는 정렬에서 제외되고, 두번째로 큰 원소가 N-1번째에 위치하게 된다. 이렇게 총 N번을 반복해서 정렬을 수행 

### JAVA Code

```java
public static int[] bubbleSort(int[] arr){

        for(int i=0;i<arr.length;i++){ // 각 배열마다 원소의 최댓값을 위치시키기 위함 (제외될 원소의 갯수)

            for(int j=0;j<arr.length-i-1;j++){ // for 문이 한번 돌때마다 가장 뒤에 있는 배열에 최댓값이 삽입되기 때문에, 이미 배정받은 원소를 제외하기 위해 i 를 마이너스 해주는 것

                if(arr[j]>arr[j+1]){ // 각 인덱스마다 인덱스의 오른쪽 값과 비교해서 swap 해줌
                    int temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }

        }
        return arr;
    }
```

### 시간복잡도

⇒ (N-1)+(N-2)+….+1 ⇒ N(N-1)/2 이므로 O(N^2) 이다. 

 


### 장점

- 알고리즘이 단순해 구현이 간단함
- 대부분의 원소가 이미 정렬되어 있을 경우, 매우 효율적
- 정렬하고자 하는 배열 안에서 교환하는 방식으로, 다른 메모리 공간을 필요로 하지 않음
    
    ⇒ 제자리 정렬
    
- 안정 정렬 (Stable Sort)



### 단점

- 최악, 최선, 평균 모두 O(N^2)으로 비효율적
- 정렬 돼있지 않은 원소가 정렬 됐을 때, Swap 연산이 많이 일어남

### Stable Sort (안정 정렬) 와 Unstable Sort (불안정 정렬)

Stable Sort의 경우 같은 숫자라도 상대적인 위치가 유지되는 정렬

4 2 2 1 3 5 2  → 1 2 2 2 3 4 5 

Unstable Sort의 경우 상대적인 위치가 유지되지 않을 수 있다.
