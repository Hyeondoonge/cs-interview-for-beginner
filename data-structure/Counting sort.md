## Counting sort

원소들의 빈도수를 카운팅한 값을 이용하여 정렬한다. 원소들끼리 비교를 수행하지 않는다.

### 동작 방식

1. 입력 배열의 원소 중 최대값을 크기로 하는 카운팅 배열을 생성한다.
   ```c++
   int arr[5] = [2, 13, 55, 88, 100];
   int counting[101];
   ```
2. 원소를 순회하며 빈도수를 계산한다.
3. 빈도수에 대한 누적합을 구한다. 이때 계산된 누적합은 다음 인덱스에 저장한다.
4. 원소를 순회하며 보조배열에다가 해당하는 start index 저장한다. 이때 start index를 1 증가시킨다.

### 시간복잡도와 공간복잡도

시간복잡도는 O(n)으로 정렬 속도가 아주 빠르다. 그리고 공간복잡도는 O(n + k)이다. 여기서 k는 입력배열 내의 최대값을 의미한다.

### 장점 및 단점

**장점**

- O(n)으로 정렬 속도가 빠르다.
- 구현이 간단하다.

**단점**

- 제한적이다. 각 언어에서 제공하는 배열 최대 크기가 제한적이여서, 최대값이 이보다 크면 알고리즘을 적용하기 어렵다.

- 메모리가 낭비된다. 입력 배열의 크기가 크면서 값의 분포가 불균등할 경우를 가정하면, counting 배열에 사용하지 못하고 남는 메모리공간이 많이 발생할 수 있다.
