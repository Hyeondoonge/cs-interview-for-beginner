## 메모리 계층 구조

![제목 없는 다이어그램 drawio](https://user-images.githubusercontent.com/55647436/223096988-48960b3e-93f2-4e5e-a7d3-1be24a335c22.png)

계층에서 아래에서 위로 갈수록 작고 비싼 메모리임을 의미한다.

## 레지스터

CPU내에서 자료를 보관하는 메모리로, 모든 메모리 중 CPU로부터 가장 빠른 속도로 접근 가능하다.

### 종류

- 범용 레지스터: 데이터와 주소 모두 저장
- 용도 지정 레지스터: 명령 레지스터, 프로그램 카운터, 데이터 레지스터, 주소 레지스터 등

### 구성

프로세서의 종류마다 구성이나 레지스터 개수가 다르다. 일반적인 구성은 다음과 같다.

- PC(Program Counter): 다음에 실행할 명령어 주소
- IR(Instructio Regiser): 현재 실행 중인 명령어
- MAR(Memoery Address Register): 메모리로부터 읽어오거나 쓰기위한 주소
- MBR(Memory Buffer Register): 메모리로부터 읽어오거나 쓰기위한 데이터

## 캐시 메모리

속도가 빠른 장치와 느린 장치사이에서의 처리 속도 차이를 개선하기 위한 하드웨어이다.
캐시에 원하는 값이 있으면 캐시 히트(hit), 없다면 캐시 미스(miss)가 발생했다고한다.

### 지역성의 원리

캐시는 히트율을 높이기위해 지역성에 근거해 메인메모리로부터 값들을 읽어들인다. 지역성에는 2가지 종류가 있다.

1. 공간적 지역성: 참조된 주변의 값들을 미래에 참조할 가능성이 높음.
2. 시간적 지역성: for나 while문과 같은 반복문 내에 사용된 값은 미래에 참조할 가능성이 높음.

### 사상 방식

캐시 메모리 상에 물리 메모리 상의 주소가 매핑 되는 방식

1. Direct mapped cache

   지정된 인덱스에 매핑하는 방식이다. 물리적 주소가 하나의 인덱스에 대응되는 것이다.
   탐색 속도가 O(1)로 매우 빠르다. 하지만 충돌이 많이 발생할 수 있어 다른 방법에 비해 충돌율이 높다.

2. N-way set associative

   지정된 인덱스에 매핑되고 N개의 way중 하나에 대응하는 방식이다. 탐색 속도가 O(N)이다. Direct mapped 방식에 비해 충돌율이 낮다. Direct, Fully associative 사이의 성능을 가지고 있다고 할 수 있다.

3. Fully associative

   지정되는 인덱스가 없다. 원하는 값을 찾기위해 모든 저장된 캐시 데이터를 읽어야한다 따라서 탐색 속도가 매우 느리다. 캐시 히트율이 높고, 충돌율이 낮다.

## 메인 메모리

CPU와 하드디스크 사이에 위치하는 메모리이다.
프로그램이 실행되기 위해서 이 메모리에 적재되어야한다.
프로세스 실행 중 명령어 또는 데이터를 가져오기 위해 물리적 주소에 접근해야는데, 이 물리적 주소는
메인 메모리 상의 주소를 의미한다.

### MMU (Memory mangament unit)

프로세스 실행 중 명령어 또는 데이터를 가져오려면, 논리적 주소를 물리적 주소로 변환하는 작업이 필요하다.
MMU는 그런 역할을 하는 하드웨어다.

![](https://o.quizlet.com/ZRmexX4AXeX6ZoxLIjW1fw.jpg)

- 논리적 주소를 물리적 주소로 변환

- 메모리 보호

  CPU가 요청한 가상 메모리 주소가 접근 가능한 물리 주소를 벗어난 값일 수도 있다.
  이를 위해 논리적 주소와 limit register의 주소를 비교한다. 논리적 주소값이 더 작다면 유효한 주소를 요청한 것이다.
  만약 범위 밖의 주소값을 요청했다면 trap을 발생시키고, OS단에서 이를 처리한다.

## 가상 메모리

한정된 메인 메모리의 용량을 개선하기위해 보조기억장치의 공간의 일부를 이용하는 기술이다.

가상 메모리의 사용으로 얻을 수 있는 이점은 멀티 프로그래밍의 수를 늘릴 수 있다는 것과 메인 메모리보다 크기가 큰 프로그램도 실행시킬 수 있다는 것이다.

![virtual memory](https://user-images.githubusercontent.com/55647436/223123134-1e36c1c9-720d-4e8d-8879-17d6ec3875a3.png)

### 요구 페이징

초기에 프로그램 전체를 메인 메모리에 적재하는 것이 아닌, 당장 실행에 필요한 페이지들만 메인 메모리에 올리고 나머지는 가상 메모리에 올리는 것이다. 후에 프로세스 작업 중, 특정 페이지가 필요하게되면 그때 가상 메모리의 페이지를 메인 메모리에 적재하여 사용하는 방식이다.

### 페이지 부재

요구 페이징으로 인해 요청하는 페이지가 메인 메모리에 올라와있지 않는 상황을 의미한다.
이때 페이지 부재 trap을 발생시키고 OS가 루틴에 따라 이를 처리한다.
