## 페이지 교체 알고리즘

메인메모리의 공간은 한정적이기때문에, 새로운 페이지를 적재하기 위해서는 희생될 페이지를 선정해야한다.
이때 어떤 알고리즘을 사용하는지에 따라 성능이 달라진다. 성능이 좋다는 것은 페이지 부재율이 낮다는 것을 의미한다.

### OPT(Optimal)

가장 오랫동안 사용되지 않을 페이지를 교체하는 방식으로 최적 방식

- 가장 낮은 페이지 부재율
- 실제로 구현 불가능

### FIFO(First-In-First-Out)

가장 먼저 올려진 페이지를 교체하는 방식.

- 이해하기 쉽고, 구현이 쉬움
- Belady 모순 발생 가능(프레임 수가 많아져도 성능이 저하되는 상황있음)
- Queue 자료구조로 구현

### LRU(Least-Recently-Used)

가장 오랫동안 사용되지 않은 페이지를 교체하는 방식

- 최적에 가까운 방식
- Linked List 자료구조로 구현, O(1)로 빠른 연산 가능

### LFU(Least-Frequently-Used)

가장 적게 참조된 페이지를 교체하는 방식.

- 참조횟수 정보 필요
- LRU보다 교체 성능 낮음
- Heap 자료구조로 구현, O(logN)로 빠른 연산 가능

### MFU(Most-Frequently-Used)

가장 많이 참조된 페이지를 교체하는 방식.

- 참조횟수 정보가 필요함
- LRU보다 교체 성능 낮음
- LFU알고리즘과 같이 Heap 자료구조로 구현, O(logN)로 빠른 연산 가능

### Clcok Algorithm

LRU의 근사 알고리즘으로, Second change algorithm 또는 NRU(Not recently used)라고도 불림.

부재가 발생했을 때 운영체제 희생 페이지를 선정한다. 이를 위해 포인터를 한 칸씩 옮기면서 Page table의 reference bit을 검사한다. 값이 1이면 0으로 바꾸고, 0이면 그 페이지를 희생 페이지로 선정한다.

- Paging system에 적용할 수 있는 방식
- modified bit을 사용해 변경되지 않은 페이지를 우선적으로 선정하여 성능 개선 가능
